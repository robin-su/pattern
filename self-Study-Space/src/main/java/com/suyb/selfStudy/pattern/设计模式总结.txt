

1.单例模式适合，只要一个实例时的情况

2.抽象工厂适合，出现产品族的情况

3.创造者模式，适合构建非常复杂的对象的情况

4.原型模式，适合new一个实例很耗费时间和资源的情况

5.适配器模式，适合旧系统升级

6.代理模式，可以不改变原有的代码，而添加方法。例如在一个方法前后加日志

7.桥接模式，适合多层继承结构，用分维度的方法来搞定继承过程中类的臃肿和添加不方便问题

8.组合模式，把部分和整体的关系用树形结构来表示，从而客户端可以使用统一的方式处理部分对象和整体对象

9.装饰模式，可以动态的给对象添加新的功能。装饰模式是一种用于代替继承的技术，无需通过继承添加子类就能拓展对象的新功能。（车子Icar例子）

10.外观模式,仅仅是提供了封装而已，并没有什么好的东西

11.享元模式,如果存在很多相同或相似的对象，我们可以通过享元模式，节省内存（黑白棋例子）

12.责任链模式，将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，
   如果能则处理，如果不能则传递给链上的下一个对象 （可用于扩展）

13.迭代器模式，适合于使用hasNext和next遍历的这种情况

14.中介者模式，解耦多个事件对象之间的交互关系。每个对象都持有中介者对象的应用，只跟中介者对象打交道。（总经理审批例子）

15.命令模式：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。
	     也称为（动作模式），或者事务模式。命令的撤销和恢复，需要集合备忘录模式！

16.策略模式，不同客户不同的报价策略，策略模式对应某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便更换算法或者增加新的算法，
   并由客户端决定调用哪个算法

17.模板方法，定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。

18.状态模式，不同的状态对应不同的行为，特别是if  else中出现了很多状态，每个状态对应不同的操作，就可以考虑使用状态模式

19.观察者模式，适合广播，试着订阅者的状态和发布者一致（监听器之类的，聊天，游戏，邮件，群发消息的时候）


20.备忘录模式，运行中断的处理，例如事务回滚，偏移量的恢复


